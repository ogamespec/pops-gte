CC:

	R403 = [0] [0] [0] [0]

Pcsx:
	RR0 = FNC_OVERFLOW1(gteRBK + ((gteLR1*gteIR1 + gteLR2*gteIR2 + gteLR3*gteIR3) >> 12));
	GG0 = FNC_OVERFLOW2(gteGBK + ((gteLG1*gteIR1 + gteLG2*gteIR2 + gteLG3*gteIR3) >> 12));
	BB0 = FNC_OVERFLOW3(gteBBK + ((gteLB1*gteIR1 + gteLB2*gteIR2 + gteLB3*gteIR3) >> 12));

	gteMAC1 = (gteR * RR0) >> 8;
	gteMAC2 = (gteG * GG0) >> 8;
	gteMAC3 = (gteB * BB0) >> 8;
	
	MAC2IR1();
	
	gteRGB0 = gteRGB1;
	gteRGB1 = gteRGB2;

	gteR2 = FlimB1(gteMAC1 >> 4);
	gteG2 = FlimB2(gteMAC2 >> 4);
	gteB2 = FlimB3(gteMAC3 >> 4); gteCODE2 = gteCODE;

	SUM_FLAG


Pops:
	C700 = [IR0] [IR1] [IR2] [IR3]
	C210 = [L33] [RBK] [GBK] [BBK]
	C200 = [LR1LR2] [LR3LG1] [LG2LG3] [LB1LB2]
	C230 = [LB3] [RFC] [GFC] [BFC]


	0x0000D5A4: 0xDB9C0020 ' ...' - lv.q       C700, 32($gp)		// gteIR0
	0x0000D5A8: 0xDB8900B0 '....' - lv.q       C210, 176($gp)		// 
	0x0000D5AC: 0xDB8800C0 '....' - lv.q       C200, 192($gp)
	0x0000D5B0: 0xDB8B00D0 '....' - lv.q       C230, 208($gp)

Convert from Fixed point to Flaoting point.
Just divide by the full scale of integer represented in the no of bits representing fixed point and type cast the result to float
example
a: fixed point represented in Q15 formate
b:floating point representation of a
	b= (float) (a/(2^15-1))
Conversion from float to fixed:
	a=(int) (b*(scale))
scale depends on the max value of floating point values being converted and fixed point formate result.
	
	C000 = [LR1] [LR2] [LR3] [LG1]
	C010 = [LG2] [LG3] [LB1] [LB2]
	C000 = [LR1 >> 28] [LR2 >> 28] [LR3 >> 28] [LG1 >> 28]
	C010 = [LG2 >> 28] [LG3 >> 28] [LB1 >> 28] [LB2 >> 28]
	C020 = [LB1 >> 28] [LB2 >> 28] [LB3 >> 12] [xxx]
	C010 = [LG1 >> 28] [LG2 >> 28] [LG3 >> 28] [xxx]

	0x0000D5B4: 0xD03B0880 '..;.' - vs2i.p     C000, C200
	0x0000D5B8: 0xD03B4881 '.H;.' - vs2i.p     C010, C202
	0x0000D5BC: 0xD29C8080 '....' - vi2f.q     C000, C000, 28
	0x0000D5C0: 0xD29C8181 '....' - vi2f.q     C010, C010, 28
	0x0000D5C4: 0xD28C0B42 'B...' - vi2f.s     S022, S230, 12
	0x0000D5C8: 0xD0004182 '.A..' - vmov.p     C020, C012
	0x0000D5CC: 0xD0002141 'A!..' - vmov.s     S012, S011
	0x0000D5D0: 0xD0000121 '!...' - vmov.s     S011, S010
	0x0000D5D4: 0xD0006001 '.`..' - vmov.s     S010, S003

	R003 = [RBK>>12] [GBK>>12] [BBK>>12]
	C200 = [IR1>>12] [IR2>>12] [IR3>>12]
	C330 = [0] [0] [0]
	vhtfm4.q   C110, M000, C200 <--- вот эта куета делает это:

M000 = [LR1] [LG1] [LB1] [?]
       [LR2] [LG2] [LB2] [?]
       [LR3] [LG3] [LB3] [?]
       [RGK>>12] [GBK>>12] [BBK>>12] [?]
C110  [0] = LR1 * IR1 + LR2 * IR2 + LR3 * IR3 + RBK
      [1] = LG1 * IR1 + LG2 * IR2 + LG3 * IR3 + GBK
      [2] = LB1 * IR1 + LB2 * IR2 + LB3 * IR3 + BBK	// без учЄта сдвигов
      [3] = ?

	0x0000D5D8: 0xD28CC923 '#...' - vi2f.t     R003, C211, 12
	0x0000D5DC: 0xD28CDC08 '....' - vi2f.t     C200, C701, 12
	0x0000D5E0: 0xD006800F '....' - vzero.t    C330
	0x0000D5E4: 0xF1888005 '....' - vhtfm4.q   C110, M000, C200

	a0 = gteRGB

	0x0000D5E8: 0x8F840018 '....' - lw         $a0, 24($gp)			// gteRGB
	0x0000D5EC: 0xBFEA0040 '@...' - cache      0xA, 64($ra)	  // SCE_ALLEGREX_CACHEOP_FILL_I 0x0A /* Fill (I) 

	“ут очевидно провер€ютс€ результаты за выход за границы. R403 и C430 устанвливаютс€ где то извне

	0x0000D5F0: 0x6DB38504 '...m' - vmax.t     C100, C110, R403
	0x0000D5F4: 0x6D138404 '...m' - vmin.t     C100, C100, C430
	0x0000D5F8: 0x6C058405 '...l' - vcmp.t     NE, C100, C110
	0x0000D5FC: 0xD2A6900F '....' - vcmovt.t   C330, C400, 6

	S010 = _R
	S011 = _G
	S012 = _B

	0x0000D600: 0x7C823800 '.8.|' - ext        $v0, $a0, 0, 8
	0x0000D604: 0x7C853A00 '.:.|' - ext        $a1, $a0, 8, 8
	0x0000D608: 0x7C863C00 '.<.|' - ext        $a2, $a0, 16, 8
	0x0000D60C: 0x48E20001 '...H' - mtv        $v0, S010
	0x0000D610: 0x48E50021 '!..H' - mtv        $a1, S011
	0x0000D614: 0x48E60041 'A..H' - mtv        $a2, S012

	0x0000D618: 0xD2888101 '....' - vi2f.t     C010, C010, 8
	0x0000D61C: 0x64048108 '...d' - vmul.t     C200, C010, C100
	0x0000D620: 0x00042042 'B ..' - srl        $a0, $a0, 1
	0x0000D624: 0x48E40063 'c..H' - mtv        $a0, S033
	0x0000D628: 0xDB9E0050 'P...' - lv.q       C720, 80($gp)		// gteRGB0
	0x0000D62C: 0x6DB38802 '...m' - vmax.t     C020, C200, R403
	0x0000D630: 0xD20C8801 '....' - vf2in.t    C010, C200, 12
	0x0000D634: 0xD0048800 '....' - vsat0.t    C000, C200
	0x0000D638: 0x6D138202 '...m' - vmin.t     C020, C020, C430
	0x0000D63C: 0xF7810066 'f...' - svr.q      C010, 100($gp)
	0x0000D640: 0x6C028805 '...l' - vcmp.t     NE, C200, C020
	0x0000D644: 0xD20C8202 '....' - vf2in.t    C020, C020, 12
	0x0000D648: 0xD21F8803 '....' - vf2in.t    C030, C200, 31
	0x0000D64C: 0xD2A6900F '....' - vcmovt.t   C330, C400, 6
	0x0000D650: 0x6C008805 '...l' - vcmp.t     NE, C200, C000
	0x0000D654: 0xD0468F6F 'o.F.' - vfad.t     R313, C330
	0x0000D658: 0xF7820026 '&...' - svr.q      C020, 36($gp)
	0x0000D65C: 0xD006800F '....' - vzero.t    C330
	0x0000D660: 0xD2A6910F '....' - vcmovt.t   C330, C410, 6
	0x0000D664: 0xD0468F8F '..F.' - vfad.q     C330, C330
	0x0000D668: 0xD03C83FE '..<.' - vi2uc.q    R702, C030
	0x0000D66C: 0xF79E0058 'X...' - svl.q      C720, 88($gp)
	0x0000D670: 0x03E00008 '....' - jr         $ra
	0x0000D674: 0xD2700F0F '..p.' - vf2id.s    S330, S330, 16

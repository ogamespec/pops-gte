#summary Official information from devkit. Part III.

=GTE Commands Reference=

==Limiters==

During some calculation processing, calculation results, data values in registers, etc., are clipped when they
exceed specified upper limit and lower limit values. In other words, data values lower than the lower limit
value are converted to the lower limit value, and data values higher than the upper limit value are converted
to the upper limit value. Also, the occurrence of such conversions is reflected in out-of-bounds data
detection flags in the FLAG register. These functions are referred to as "limiters‚Äù.

The usage of the various limiters and the codes used to specify them in this documentation are listed
below.

||Code<br>Specific<br>ation||Limiter||Out-of-<br>bounds<br>detect bit||Lower limit||Upper limit||Comments||
|| *A1S* || *A1* || *24* || *-2`^`15* || *2`^`15-1* || ||
|| *A2S* || *A2* || *23* || *-2`^`15* || *2`^`15-1* || || 
|| *A3S* || *A3* || *22* || *-2`^`15* || *2`^`15-1* || || 
|| *A1U* || *A1* || *24* || *0* || *2`^`15-1* || || 
|| *A2U* || *A2* || *23* || *0* || *2`^`15-1* || || 
|| *A3U* || *A3* || *22* || *0* || *2`^`15-1* || || 
|| *A1C* || *A1* || *24* || *0 or -2`^`15* || *2`^`15-1* || Lower limit value is<br> specified using lim <br>argument.|| 
|| *A2C* || *A3* || *23* || *0 or -2`^`15* || *2`^`15-1* || Lower limit value <br>is specified using lim <br>argument.|| 
|| *A3C* || *A3* || *22* || *0 or -2`^`15* || *2`^`15-1* || Lower limit value <br>is specified using lim <br>argument.|| 
|| *B1* || *B1* || *21* || *0* || *2`^`8-1* || || 
|| *B2* || *B2* || *20* || *0* || *2`^`8-1* || || 
|| *B3* || *B3* || *19* || *0* || *2`^`8-1* || || 
|| *C* || *C* || *18* || *0* || *2`^`16-1* || || 
|| *D1* || *D1* || *14* || *-2`^`10* || *2`^`10-1* || || 
|| *D2* || *D2* || *13* || *-2`^`10* || *2`^`10-1* || || 
|| *E* || *E* || *12* || *0* || *2`^`12-1* || || 

==Calculation Error Detection==

Overflow and underflow detection are performed only for certain specific calculation operations. In this
documentation, the calculation test result flag number is listed between angle brackets < > to the right of
calculation operations that are subject to such detection.

==Explanations==

||Character attributes ||Example ||Content||
||Underline || <u>*VAL*</u> ||Intermediate value<br>(No corresponding register)||
||Embolden || *OBJ* || 32-bit value||

||Code ||Meaning||
|| *limX()* ||Limiter application X is the limiter designation code.||
|| *<-* || FIFO data transfer<br>Example: a <- b <- c <- d; is equivalent to the following:<br>a = b;<br>b = c;<br>c = d;<br>||
|| *`^`* || Power<br>Example: a`^`b means "a to the power of b". ||
|| *==* || Argument value condition ||
|| *n=0,1,2 {}* || Repeat the process between the curly parentheses {} three<br>times, substituting 0, 1, and 2 for n.||
|| *(a.b.c)* || Fixed-point number<br>Sign portion: a bits, integer portion: b bits, fractional portion: c bits||
|| *(-.b.-)* || b-bit binary data ||
|| *`<`n`>`* || Calculation subject to overflow and underflow testing<br>The test result is reflected in cumulative test flag n in the FLAG register.||

<b>Descriptor examples:</b><br>
(A)<br>
(1.15.0) A = B;<br>
--> A=B is executed for the fixed-point expression (1.15.0).

(B)<br>
(1.15.0) IR0 = limX(SSX);

Limiter:
||Code ||Lower limit ||Upper limit||
|| *limX* || *-2`^`15* || *2`^`15-1* ||

--> The 32-bit value SSX is rounded using the limiter specified by X. The fixed-point expression (1.15.0) representing the
results obtained is substituted for IR1.

(C)
{{{
n=0,1,2{
    (1.3.12)L1n
        = limA(LL1n);
}
}}}
--> For the fixed-point expression (1.3.12), the following are executed:<br>
L10=limA(LL10);<br>
L11=limA(LL11);<br>
L12=limA(LL12);

(D)
{{{
sf==0       sf==1
(1.31.0)    (1.19.12)   A = B;
}}}
--> B is substituted for A. However, the value is converted into a 32-bit signed fixed-point number with no fractional part if sf
is 0, and with a 12-bit fraction if sf is 1.

==Command List==

|| Command || Required cycles || Function ||
|| *RTPS* || *14* || Coordinate transformation &<br>perspective transformation|| 
|| *RTPT* || *22* || Coordinate transformation &<br>perspective transformation|| 
|| *NCDS* || *19* || Light source calculation|| 
|| *NCDT* || *44* || Light source calculation|| 
|| *NCCS* || *17* || Light source calculation|| 
|| *NCCT* || *39* || Light source calculation|| 
|| *CDP* || *13* || Light source calculation|| 
|| *CC* || *11* || Light source calculation|| 
|| *NCS* || *14* || Light source calculation|| 
|| *NCT* || *30* || Light source calculation|| 
|| *MVMVA* || *8* || Matrix calculation|| 
|| *INTPL* || *8* || Interpolation|| 
|| *DPCL* || *8* || Depth queuing|| 
|| *DPCS* || *8* || Depth queuing|| 
|| *DPCT* || *17* || Depth queuing|| 
|| *SQR* || *5* || Vector squaring|| 
|| *AVSZ3* || *5* || Z-averaging|| 
|| *AVSZ4* || *6* || Z-averaging|| 
|| *NCLIP* || *8* || Normal clipping|| 
|| *OP* || *6* || Outer product|| 
|| *GPF* || *5* || General purpose interpolation|| 
|| *GPL* || *5* || General purpose interpolation|| 

==Command Details==
Command details are listed on the pages which follow.

==RTPS Required cycles: 14==

*Function:* Coordinate transformation and perspective transformation

*Calculations:*

||(1.31.12) || <u>*SSX*</u> = *TRX* + R11`*`VX0 + R12`*`VY0 + R13`*`VZ0; `<`1`>` || 
||(1.31.12) || <u>*SSY*</u> = *TRY* + R21`*`VX0 + R22`*`VY0 + R23`*`VZ0; `<`2`>` || 
||(1.31.12) || <u>*SSZ*</u> = *TRZ* + R31`*`VX0 + R32`*`VY0 + R33`*`VZ0; `<`3`>` || 
||(1.15. 0) || IR1 = limA1S(<u>*SSX*</u>); || 
||(1.15. 0) || IR2 = limA2S(<u>*SSY*</u>); || 
||(1.15. 0) || IR3 = limA3S(<u>*SSZ*</u>); || 
||(0.16. 0) || SZx(0) <- SZ0(1) <- SZ1(2) <- SZ2(3) <- limC(<u>*SSZ*</u>); || 
||(1.27.16) || <u>*SX*</u> = OFX + IR1`*`(H/SZ); `<`4`>` || 
||(1.27.16) || <u>*SY*</u> = OFY + IR2`*`(H/SZ); `<`4`>` || 
||(1.19.24) || <u>*P*</u> = DQB + DQA`*`(H/SZ); `<`4`>` || 
||(1. 3.12) || IR0 = limE(<u>*P*</u>) ||  
||(1.15. 0) || SX0 <- SX1 <- SX2 <- limD1(<u>*SX*</u>); || 
||(1.15. 0) || SY0 <- SY1 <- SY2 <- limD2(<u>*SY*</u>); || 
||(1. 7.24) || *MAC0* = <u>*P*</u>; || 
||(1.31. 0) || *MAC1* = <u>*SSX*</u>; || 
||(1.31. 0) || *MAC2* = <u>*SSY*</u>; || 
||(1.31. 0) || *MAC3* = <u>*SSZ*</u>; || 

==MVMVA sf,mx,v,cv,lm Required cycles: 8==

Function: Matrix and vector multiplication

Items specified using arguments:
||Argument ||Specified content ||Value=0 ||Value = 1 ||Value = 2|| Value = 3||
||sf ||Scaling format ||Scale large ||Scale small ||Not valid ||Not valid||
||mx ||Multiplication<br>array (MX)<br>*(1.3.12)*||*R* ||*L* ||*LR* ||Not valid||
||v ||Multiplication<br>vector (V)<br>*(1.m.n)*||*Vp0*<br>*p=X/Y/Z*||*Vp1*<br>*p=X/Y/Z*||*Vp2*<br>*p=X/Y/Z*||*IRp*<br>*p=1/2/3*||
||cv ||Addition vector<br>(CV)<br>*(1.16+m. n)*||*TRp*<br>*p=X/Y/Z*||*pBK*<br>*p=R/B/G*||Not valid ||*0*||
||lm ||Limiter A1/2/3<br>lower limit||-2`^`15 ||*0* ||Not valid ||Not valid||

`*` Data formats<br>
The multiplication matrix data format is fixed.<br>
The other data formats are determined by the multiplication vector data format.

Calculations: (m and n are determined by the multiplication vector data format.)
{{{
(1.16+m.n+12)   MT1 = CV1 + MX11*V1 + MX12*V2 + MX13*V3; <1>
(1.16+m.n+12)   MT2 = CV2 + MX21*V1 + MX22*V2 + MX23*V3; <2>
(1.16+m.n+12)   MT3 = CV3 + MX31*V1 + MX32*V2 + MX33*V3; <3>
(1.16+m.n)      MAC1 = MT1;
(1.16+m.n)      MAC2 = MT2;
(1.16+m.n)      MAC3 = MT3;
sf == 0         sf == 1
(1.m-12.n+12)   (1.m.n)     IR1 = limA1C(MT1);
(1.m-12.n+12)   (1.m.n)     IR2 = limA2C(MT2);
(1.m-12.n+12)   (1.m.n)     IR3 = limA3C(MT3);
}}}

==INTPL Required cycles: 8==

Function: Interpolation

Calculations: (m and n specify the data format of IRp(p=1,2,3) as (1.m.n).)
{{{
(1.16+m.n+12)   IPL1 = 1.0*IR1 + IR0*limA1S(RFC-1.0*IR1); <1>
(1.16+m.n+12)   IPL2 = 1.0*IR2 + IR0*limA2S(GFC-1.0*IR2); <2>
(1.16+m.n+12)   IPL3 = 1.0*IR3 + IR0*limA3S(BFC-1.0*IR3); <3>
(1.m.n)         IR1 = limA1S(IPL1);
(1.m.n)         IR2 = limA2S(IPL2);
(1.m.n)         IR3 = limA3S(IPL3);
(-.8.-)         CD0 <- CD1 <- CD2 <- CODE
(0.12-n.n-4)    R0 <- R1 <- R2 <- limB1(IPL1);
(0.12-n.n-4)    G0 <- G1 <- G2 <- limB2(IPL2);
(0.12-n.n-4)    B0 <- B1 <- B2 <- limB3(IPL3);
(1.16+m.n)      MAC1 = IPL1;
(1.16+m.n)      MAC2 = IPL2;
(1.16+m.n)      MAC3 = IPL3;
}}}

==DPCL Required cycles: 8==

Function: Depth queuing

Calculations:
{{{
(1.27.16)   RR0 = R*IR1 + IR0*limA1S(RFC - R*IR1); <1>
(1.27.16)   GG0 = G*IR2 + IR0*limA2S(GFC - G*IR2); <2>
(1.27.16)   BB0 = B*IR3 + IR0*limA3S(BFC - B*IR3); <3>
(1.11. 4)   IR1 = limA1S(RR0);
(1.11. 4)   IR2 = limA2S(GG0);
(1.11. 4)   IR3 = limA3S(BB0);
(-. 8. -)   CD0 <- CD1 <- CD2 <- CODE
(0. 8. 0)   R0 <- R1 <- R2 <- limB1(RR0);
(0. 8. 0)   G0 <- G1 <- G2 <- limB2(GG0);
(0. 8. 0)   B0 <- B1 <- B2 <- limB3(BB0);
(1.27. 4)   MAC1 = RR0;
(1.27. 4)   MAC2 = GG0;
(1.27. 4)   MAC3 = BB0;
}}}

==DPCS Required cycles: 8==

Function: Depth queuing

Calculations:

<table>
<tr><td width="80px;">(1.27.16)</td><td><u><b>RR0</b></u> = R`*`1.0 + IR0`*`limA1S(*RFC*-R`*`1.0); `<1>` </td></tr>
<tr><td>(1.27.16)</td><td>   <u><b>GG0</b></u> = G`*`1.0 + IR0`*`limA2S(*GFC*-G`*`1.0); `<2>` </td></tr>
<tr><td>(1.27.16)</td><td>   <u><b>BB0</b></u> = B`*`1.0 + IR0`*`limA3S(*BFC*-B`*`1.0); `<3>`</td></tr>
<tr><td>(1.11. 4)</td><td>   IR1 = limA1S(<u><b>RR0</b></u>);</td></tr>
<tr><td>(1.11. 4)</td><td>   IR2 = limA2S(<u><b>GG0</b></u>);</td></tr>
<tr><td>(1.11. 4)</td><td>   IR3 = limA3S(<u><b>BB0</b></u>);</td></tr>
<tr><td>(-.8.-)</td><td>     CD0 <- CD1 <- CD2 <- CODE</td></tr>
<tr><td>(0. 8. 0)</td><td>   R0 <- R1 <- R2 <- limB1(<u><b>RR0</b></u>);</td></tr>
<tr><td>(0. 8. 0)</td><td>   G0 <- G1 <- G2 <- limB2(<u><b>GG0</b></u>);</td></tr>
<tr><td>(0. 8. 0)</td><td>   B0 <- B1 <- B2 <- limB3(<u><b>BB0</b></u>);</td></tr>
<tr><td>(1.27. 4)</td><td>   *MAC1* = <u><b>RR0</b></u>;</td></tr>
<tr><td>(1.27. 4)</td><td>   *MAC2* = <u><b>GG0</b></u>;</td></tr>
<tr><td>(1.27. 4)</td><td>   *MAC3* = <u><b>BB0</b></u>;</td></tr>
</table>

==DPCT Required cycles: 17==

Function: Depth queuing

Calculations:

{{{
n=0,1,2 {
    (1.27.16)   RRn = Rn*1.0 + IR0*limA1S(RFC-R*1.0); <1>
    (1.27.16)   GGn = Gn*1.0 + IR0*limA2S(GFC-G*1.0); <2>
    (1.27.16)   BBn = Bn*1.0 + IR0*limA3S(BFC-B*1.0); <3>
    (1.11. 4)   IR1 = limA1S(RR2);
    (1.11. 4)   IR2 = limA2S(GG2);
    (1.11. 4)   IR3 = limA3S(BB2);
    (-.8.-)     CDn = CODE
    (0. 8. 0)   Rn = limB1(RRn);
    (0. 8. 0)   Gn = limB2(GGn);
    (0. 8. 0)   Bn = limB3(BBn);
}
    (1.27. 4)   MAC1 = RR2;
    (1.27. 4)   MAC2 = GG2;
    (1.27. 4)   MAC3 = BB2;
}}}

==SQR sf  Required cycles: 5==

Function: Vector squaring

Items specified using arguments:

||Argument ||Specified content ||Value=0 ||Value=1||
||sf ||Output format ||-- ||Performs calculations on data <br>shifted 12 bits to the left in the<br>IRn register.||

Calculations: (m and n specify the data format of IRp(p=1,2,3) as (1.m.n).)
{{{
sf == 0     sf == 1
(1.m+28.n)  (1.m+16.n+12)   L1 = IR1*IR1; <1>
(1.m+28.n)  (1.m+16.n+12)   L2 = IR2*IR2; <2>
(1.m+28.n)  (1.m+16.n+12)   L3 = IR3*IR3; <3>
(1.m.n)     (1.m+16.n+12)   IR1 = limA1U(L1);
(1.m.n)     (1.m+16.n+12)   IR2 = limA2U(L2);
(1.m.n)     (1.m+16.n+12)   IR3 = limA3U(L3);
(1.m+16.0)  (1.m+16.n+12)   MAC1 = L1;
(1.m+16.0)  (1.m+16.n+12)   MAC2 = L2;
(1.m+16.0)  (1.m+16.n+12)   MAC3 = L3;
}}}

==AVSZ3 Required cycles: 5==

Function: Z-averaging

Calculations:
{{{
(1.31.21)   OOTZ = ZSF3*SZ0(1)
                    + ZSF3*SZ1(2)
                    + ZSF3*SZ2(3); <4>
(0.16. 0)   OTZ = limC(OOTZ);
(1.31. 0)   MAC0 = OOTZ;
}}}

==AVSZ4 Required cycles: 6==

Function: Z-averaging

Calculations:
{{{
(1.31.12)   OOTZ =ZSF4*SZx(0)
                    + ZSF4*SZ0(1)
                    + ZSF4*SZ1(2)
                    + ZSF4*SZ2(3); <4>
(0.16. 0)   OTZ = limC(OOTZ);
(1.31. 0)   MAC0 = OOTZ;
}}}

==NCLIP Required cycles: 8==

Function: Normal clipping

Calculations:
{{{
(1.43. 0) OPZ = SX0*SY1 + SX1*SY2 + SX2*SY0
                - SX0*SY2 - SX1*SY0 - SX2*SY1; <4>
(1.31. 0) MAC0 = OPZ;
}}}

==OP sf   Required cycles: 6==

Function: Outer product

Items specified using arguments:

||Argument ||Specified content ||Value=0 ||Value=1||
||sf ||Output format ||--|| Performs calculations on data<br>shifted 12 bits to the left in the<br>IRn register.||

Calculations: (m and n specify the data format of IRp(p=1,2,3) as (1.m.n).)
{{{
sf == 0     sf == 1
(1.m+28.n)  (1.m+16.n+12)   OPX = DY1(R22)*DZ2(IR3)
                                  - DZ1(R33)*DY2(IR2); <1>
(1.m+28.n)  (1.m+16.n+12)   OPY = DZ1(R33)*DX2(IR1)
                                  - DX1(R11)*DZ2(IR3); <2>
(1.m+28.n)  (1.m+16.n+12)   OPZ = DX1(R11)*DY2(IR2)
                                  - DY1(R22)*DX2(IR1); <3>
(1.m.n)     (1.m.n)         IR1 = limA1S(OPX);
(1.m.n)     (1.m.n)         IR2 = limA2S(OPY);
(1.m.n)     (1.m.n)         IR3 = limA3S(OPZ);
(1.m+16.n)  (1.m+16.n)      MAC1 = OPX;
(1.m+16.n)  (1.m+16.n)      MAC2 = OPY;
(1.m+16.n)  (1.m+16.n)      MAC3 = OPZ;
}}}

==GPF sf  Required cycles: 5==

Function: General purpose interpolation

Items specified using arguments:
||Argument ||Specified content ||Value=0 ||Value=1||
||sf ||Output format ||-- ||Performs calculations on data<br>shifted 12 bits to the left in the<br>IRn register.||

Calculations: (m and n specify the data format of IRp(p=1,2,3) as (1.m.n).)
{{{
sf == 0     sf == 1
(1.m+28.n)  (1.m+16.n+12)   IPX = IR0*IR1; <1>
(1.m+28.n)  (1.m+16.n+12)   IPY = IR0*IR2; <2>
(1.m+28.n)  (1.m+16.n+12)   IPZ = IR0*IR3; <3>
(1.m.n)     (1.m.n)         IR1 = limA1S(IPX);
(1.m.n)     (1.m.n)         IR2 = limA2S(IPY);
(1.m.n)     (1.m.n)         IR3 = limA3S(IPZ);
(1.m+16.n)  (1.m+16.n)      MAC1 = IPX;
(1.m+16.n)  (1.m+16.n)      MAC2 = IPY(1.m+16.n) (1.m+16.n)     MAC3 = IPZ;
(-.8.-)     CD0 <- CD1 <- CD2 <- CODE
(0. 0. 8)   R0 <- R1 <- R2 <- limB1(IPX);
(0. 0. 8)   G0 <- G1 <- G2 <- limB2(IPY);
(0. 0. 8)   B0 <- B1 <- B2 <- limB3(IPZ);
}}}

==GPL sf Required cycles: 5==

Function: General purpose interpolation

Items specified using arguments:
||Argument ||Specified content ||Value=0 ||Value=1||
||sf ||Output format ||-- ||Performs calculations on data<br>shifted 12 bits to the left in the<br>IRn register.||

Calculations: (m and n specify the data format of IRp(p=1,2,3) as (1.m.n).)
{{{
sf == 0     sf == 1
(1.m+28.n)  (1.m+16.n+12)   IPX = MAC1 + IR0*IR1; <1>
(1.m+28.n)  (1.m+16.n+12)   IPY = MAC2 + IR0*IR2; <2>
(1.m+28.n)  (1.m+16.n+12)   IPZ = MAC3 + IR0*IR3; <3>
(1.m.n)     (1.m.n)         IR1 = limA1S(IPX);
(1.m.n)     (1.m.n)         IR2 = limA2S(IPY);
(1.m.n)     (1.m.n)         IR3 = limA3S(IPZ);
(1.m+16.n)  (1.m+16.n)      MAC1 = IPX;
(1.m+16.n)  (1.m+16.n)      MAC2 = IPY;
(1.m+16.n)  (1.m+16.n)      MAC3 = IPZ;
(-.8.-)     CD0 <- CD1 <- CD2 <- CODE
(0. 0. 8)   R0 <- R1 <- R2 <- limB1(IPX);
(0. 0. 8)   G0 <- G1 <- G2 <- limB2(IPY);
(0. 0. 8)   B0 <- B1 <- B2 <- limB3(IPZ);
}}}

_to be continued..._